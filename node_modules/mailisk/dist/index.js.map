{"version":3,"sources":["../src/index.ts","../src/mailisk.ts"],"sourcesContent":["export * from \"./mailisk\";\n","import axios, { AxiosRequestConfig } from \"axios\";\nimport {\n  ListNamespacesResponse,\n  SearchInboxParams,\n  SearchInboxResponse,\n  SendVirtualEmailParams,\n  SmtpSettings,\n} from \"./mailisk.interfaces\";\nimport nodemailer from \"nodemailer\";\n\nexport class MailiskClient {\n  constructor({ apiKey, baseUrl }: { apiKey: string; baseUrl?: string }) {\n    this.axiosInstance = axios.create({\n      headers: {\n        \"X-Api-Key\": apiKey,\n      },\n      baseURL: baseUrl || \"https://api.mailisk.com/\",\n    });\n  }\n\n  private readonly axiosInstance;\n\n  /**\n   * List all namespaces that belong to the current account (API key).\n   */\n  async listNamespaces(): Promise<ListNamespacesResponse> {\n    return (await this.axiosInstance.get(\"api/namespaces\")).data;\n  }\n\n  /**\n   * Send an email using the Virtual SMTP.\n   *\n   * These emails can only be sent to valid Mailisk namespaces, i.e. emails that end in @mynamespace.mailisk.net\n   *\n   * @example\n   * For example, sending a test email:\n   * ```typescript\n   * client.sendVirtualEmail(namespace, {\n   *   from: \"test@example.com\",\n   *   to: `john@${namespace}.mailisk.net`,\n   *   subject: \"This is a test\",\n   *   text: \"Testing\",\n   * });\n   * ```\n   */\n  async sendVirtualEmail(namespace: string, params: SendVirtualEmailParams): Promise<void> {\n    const smtpSettings = await this.getSmtpSettings(namespace);\n\n    // TODO: to should match namespace\n\n    const transport = nodemailer.createTransport({\n      host: smtpSettings.data.host,\n      port: smtpSettings.data.port,\n      secure: false,\n      auth: {\n        user: smtpSettings.data.username,\n        pass: smtpSettings.data.password,\n      },\n    });\n\n    const { from, to, subject, text, html } = params;\n\n    await transport.sendMail({\n      from,\n      to,\n      subject,\n      text,\n      html,\n    });\n\n    transport.close();\n  }\n\n  /**\n   * Search inbox of a namespace.\n   *\n   * By default, this calls the api using the `wait` flag. This means the call won't timeout until at least one email is received or 5 minutes pass.\n   * It also uses a default `from_timestamp` of **current timestamp - 5 seconds**. This means that older emails will be ignored.\n   *\n   * Both of these settings can be overriden by passing them in the `params` object.\n   *\n   * @example\n   * Get the latest emails in the namespace\n   * ```typescript\n   * const { data: emails } = await client.searchInbox(namespace);\n   * ```\n   *\n   * @example\n   * Get the latest emails for a specific email address\n   * ```typescript\n   * const { data: emails } = await client.searchInbox(namespace, {\n   *  to_addr_prefix: 'john@mynamespace.mailisk.net'\n   * });\n   * ```\n   */\n  async searchInbox(\n    namespace: string,\n    params?: SearchInboxParams,\n    config?: AxiosRequestConfig\n  ): Promise<SearchInboxResponse> {\n    let _params = { ...params };\n\n    // default from timestamp, 15 minutes before starting this request\n    if (params?.from_timestamp === undefined || params?.from_timestamp === null) {\n      _params.from_timestamp = Math.floor(new Date().getTime() / 1000) - 15 * 60;\n    }\n\n    // by default wait for email\n    if (params?.wait !== false) {\n      _params.wait = true;\n    }\n\n    let _config = { ...config };\n\n    if (!config?.maxRedirects) {\n      _config.maxRedirects = 99999;\n    }\n\n    // by default, wait 5 minutes for emails before timing out\n    if (_params.wait && !config?.timeout) {\n      _config.timeout = 1000 * 60 * 5;\n    }\n\n    return (\n      await this.axiosInstance.get(`api/emails/${namespace}/inbox`, {\n        ..._config,\n        params: _params,\n      })\n    ).data;\n  }\n\n  /**\n   * Get the SMTP settings for a namespace.\n   */\n  async getSmtpSettings(namespace: string): Promise<SmtpSettings> {\n    const result = await this.axiosInstance.get(`api/smtp/${namespace}`);\n    return result.data;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,mBAA0C;AAQ1C,wBAAuB;AAEhB,IAAM,gBAAN,MAAoB;AAAA,EACzB,YAAY,EAAE,QAAQ,QAAQ,GAAyC;AACrE,SAAK,gBAAgB,aAAAA,QAAM,OAAO;AAAA,MAChC,SAAS;AAAA,QACP,aAAa;AAAA,MACf;AAAA,MACA,SAAS,WAAW;AAAA,IACtB,CAAC;AAAA,EACH;AAAA,EAEiB;AAAA,EAKjB,MAAM,iBAAkD;AACtD,YAAQ,MAAM,KAAK,cAAc,IAAI,gBAAgB,GAAG;AAAA,EAC1D;AAAA,EAkBA,MAAM,iBAAiB,WAAmB,QAA+C;AACvF,UAAM,eAAe,MAAM,KAAK,gBAAgB,SAAS;AAIzD,UAAM,YAAY,kBAAAC,QAAW,gBAAgB;AAAA,MAC3C,MAAM,aAAa,KAAK;AAAA,MACxB,MAAM,aAAa,KAAK;AAAA,MACxB,QAAQ;AAAA,MACR,MAAM;AAAA,QACJ,MAAM,aAAa,KAAK;AAAA,QACxB,MAAM,aAAa,KAAK;AAAA,MAC1B;AAAA,IACF,CAAC;AAED,UAAM,EAAE,MAAM,IAAI,SAAS,MAAM,KAAK,IAAI;AAE1C,UAAM,UAAU,SAAS;AAAA,MACvB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,cAAU,MAAM;AAAA,EAClB;AAAA,EAwBA,MAAM,YACJ,WACA,QACA,QAC8B;AAC9B,QAAI,UAAU,EAAE,GAAG,OAAO;AAG1B,QAAI,QAAQ,mBAAmB,UAAa,QAAQ,mBAAmB,MAAM;AAC3E,cAAQ,iBAAiB,KAAK,MAAM,IAAI,KAAK,EAAE,QAAQ,IAAI,GAAI,IAAI,KAAK;AAAA,IAC1E;AAGA,QAAI,QAAQ,SAAS,OAAO;AAC1B,cAAQ,OAAO;AAAA,IACjB;AAEA,QAAI,UAAU,EAAE,GAAG,OAAO;AAE1B,QAAI,CAAC,QAAQ,cAAc;AACzB,cAAQ,eAAe;AAAA,IACzB;AAGA,QAAI,QAAQ,QAAQ,CAAC,QAAQ,SAAS;AACpC,cAAQ,UAAU,MAAO,KAAK;AAAA,IAChC;AAEA,YACE,MAAM,KAAK,cAAc,IAAI,cAAc,mBAAmB;AAAA,MAC5D,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC,GACD;AAAA,EACJ;AAAA,EAKA,MAAM,gBAAgB,WAA0C;AAC9D,UAAM,SAAS,MAAM,KAAK,cAAc,IAAI,YAAY,WAAW;AACnE,WAAO,OAAO;AAAA,EAChB;AACF;AAhIa;","names":["axios","nodemailer"]}